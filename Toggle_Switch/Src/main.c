/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*
 * The program controls the frequency of the LED toggle base on the external interrupt coming from a Push button.
 * By default , the firmware shall toggle the LED with a frequency of 1s.
 */
#include <stdint.h>
#include <stm32f401xe.h>

static void SysTick_Init();
static void GPIO_Init();

static uint8_t Led_State =0;
volatile static uint32_t SysTick_Count =0;
static uint32_t SysTick_LastVal =0;
volatile static uint8_t Switch_State =0;
static uint32_t SysTick_IntVal =0;

void SysTick_Init()
{
	SysTick ->LOAD = 16000-1;
	SysTick ->VAL =0; 
	SysTick ->CTRL= (1U<<0 ) | (1U<<2) | (1U <<1);

}

void GPIO_Init()
{
	RCC ->AHB1ENR|= (1U<<0);
	GPIOA->MODER &= ~(3U << (2*5)); // Resets the MODER register
	GPIOA->MODER|=(1U << (2*5)); // configure pin as Output
	GPIOA ->MODER &=~(3U <<(2*0)); // clears the pin

}

void Interrupt_Init()
{
	//SYSCFG ->EXTICR = 0; // Configuring the system input to listen from PA0
	RCC->APB2ENR |=(1U << 14); // enable SYSCFGEN
	SYSCFG->EXTICR[0] &= ~(15<<0);
	SYSCFG ->EXTICR[0] |= (0U);
	EXTI->IMR |= (1U<<0);
	EXTI ->FTSR |= (1U << 0);
	NVIC_EnableIRQ(EXTI0_IRQn);
}

void SysTick_Handler()
{
	// ISR for SysTick
	SysTick_Count++;
}

void EXTI0_IRQHandler()
{
	//ISR to service interrupt from Toggle Switch
	if(SysTick_Count - SysTick_IntVal >= 50)
	{
		Switch_State = (Switch_State+1)%3;
	}

	SysTick_IntVal = SysTick_Count;
	EXTI->PR=(1U << 0);



}

void GPIO_Control(uint16_t delay_val)
{
	// Function to control


	if(Led_State == 0)
	{

		if(SysTick_Count - SysTick_LastVal >= delay_val )
		{
			GPIOA ->BSRR= (1U << 5);
			Led_State = 1;
			SysTick_LastVal = SysTick_Count;

		}

	}
	else
	{

		if(SysTick_Count - SysTick_LastVal >= delay_val )
		{
			GPIOA ->BSRR= (1U << (5+16));
			Led_State =0;
			SysTick_LastVal = SysTick_Count;
		}

	}
}
int main(void)
{
	
	GPIO_Init();
	SysTick_Init();
	Interrupt_Init();

	while(1)
	{

		if(Switch_State == 1)
		{
			GPIO_Control(500);

		}
		else if( Switch_State == 2)
		{
			GPIO_Control(200);
		}
		else
		{
			GPIO_Control(1000);
		}


	}



}
